# dataset

### **Implementation and Evaluation of a High-Performance Modular Backend Framework with WebAssembly and Rust**

- ***WASM과 Rust를 결합한 모듈형 경량 웹 백엔드 프레임워크의 설계 및 구현***

---

## 목차

1. 연구 배경 및 목적
2. 연구 내용
3. 연구 결과
4. 결론

---

# 1. 연구 배경 및 목적

## 1-1. 연구 배경

- **현대 웹 애플리케이션의 복잡성과 성능 요구 증가**
    - 실시간 데이터 처리와 대규모 사용자 대응으로 인한 성능 요구 상승
    - 사용자 경험 향상을 위한 낮은 지연 시간과 높은 응답성 필요
    - **자세한 설명**
        - **실시간 데이터 처리와 대규모 사용자 대응으로 인한 성능 요구 상승**:
            - 오늘날의 웹 애플리케이션은 단순한 정적 페이지 제공을 넘어, **실시간 데이터 업데이트**와 **대규모 사용자**와의 상호작용을 지원해야 함.
            - 예를 들어, **소셜 미디어** 플랫폼(페이스북, 트위터 등)에서는 수많은 사용자가 동시에 게시글을 작성하거나 댓글을 달고, 이러한 업데이트는 즉시 다른 사용자에게 반영되어야 함.
            - 실시간 응답성을 유지하기 위해서는 서버의 성능이 중요하므로 이러한 서비스는 수많은 요청을 처리해야 하며, 이때 느린 서버 응답은 사용자 경험을 크게 저하시킬 수 있음, **스케일링 능력**이 충분하지 않거나 성능이 떨어지는 백엔드 프레임워크를 사용하면 사용자 요청을 제때 처리하지 못하고, 이는 사용자가 이탈하는 주요 원인이 됨.
            - 따라서 실시간 처리와 대규모 대응을 위해 고성능 백엔드 프레임워크의 필요성 증대
        - **사용자 경험 향상을 위한 낮은 지연 시간과 높은 응답성 필요**:
            - 사용자 경험(UX)은 웹 애플리케이션 성공의 핵심 요소, 낮은 지연 시간(latency)과 높은 응답성(responsiveness)은 좋은 사용자 경험을 제공하는 데 중요한 역할을 함.
            - 예를 들어, **구글의 연구**에 따르면 **페이지 로딩 시간이 0.5초에서 1초로 증가할 경우 사용자의 이탈률이 크게 증가**한다고 함. **아마존** 역시 **100ms의 지연 증가가 매출에 부정적인 영향을 미친다**고 보고한 바 있음.
            - 사용자가 클릭했을 때 즉각적인 반응이 없거나 로딩 시간이 길어지면, 사용자는 불편함을 느끼고 이를 바로 떠날 가능성이 큼. **전자상거래** 사이트의 경우, **응답 시간이 지연될수록 구매 전환율**이 급감
            - 따라서 성능이 뛰어난 백엔드 프레임워크를 사용하여 낮은 지연 시간과 높은 응답성을 유지하는 것은 사용자 유지와 매출 증대에 중요한 요소. **Rust와 WASM**을 사용하면 이러한 지연을 최소화하고 높은 응답성을 제공할 수 있는 이유는, 네이티브 수준의 성능을 제공하여 서버 응답 시간을 줄일 수 있기 때문
- **기존 백엔드 프레임워크의 한계**
    - **성능 저하:** 인터프리터 언어 기반 프레임워크의 한계
    - **보안 취약점:** 메모리 관리 및 런타임 취약점으로 인한 보안 이슈
    - **위 3가지 내용에 관한 자세한 설명**
        - **성능 저하:**
            - 주로 **Node.js**나 **Python** 기반의 프레임워크(예: Express.js, Django)는 **인터프리터 언어** 기반이라 네이티브 언어에 비해 성능이 낮음.
            - 이는 JIT(Just-In-Time) 컴파일 방식이나 해석(interpretation) 과정에서 발생하는 오버헤드로 인해 응답 시간이 길어질 수 있기 때문임.
            - 특히 CPU 집약적인 작업에서 성능이 떨어지는 경향이 큼.
        - **보안 취약점:**
            - **PHP** 기반 프레임워크(예: Laravel, CodeIgniter)는 메모리 관리에서 자유롭기 때문에 **런타임에서 메모리 누수나 오버플로우 문제**가 발생할 가능성이 높음.
            - 이러한 메모리 관리 문제는 보안 취약점으로 이어질 수 있습니다. 또한, 일부 **Node.js** 프레임워크는 전역 객체나 메모리 접근 방식에서 보안 취약점을 노출.
            - 반면 **Rust**는 이러한 문제를 소유권(ownership) 모델을 통해 예방.
            - 또 WASM 모듈은 샌드박스 환경에서 실행되기 때문에 보안성과 독립성을 강화할 수 있음.
- **저비용 고성능 프레임워크의 필요성**
    - 웹 환경의 복잡성 증가로 인한 서버 부하 증가
    - 클라우드 비용 절감을 위한 효율적 자원 사용 필요
    - 경량 웹 프레임워크의 필요성이 대두됨
    - **필요성에 대한 구체적 설명**
        - **웹 환경의 복잡성 증가로 인한 서버 부하 증가**:
            - 현대의 웹 애플리케이션은 **실시간 데이터 처리**, **대규모 사용자와의 상호작용**을 지원하기 위해 복잡해지고 있음.
            - 예를 들어 **스트리밍 서비스**(넷플릭스 등)와 같은 경우 실시간으로 대량의 데이터를 전송해야 하며, 이는 서버의 부하를 증가시킴.
            - 또 인공지능 AI 서비스는 서버에서 복잡하고 집약적인 연산 로직을 처리해서 사용자에게 응답을 전송하기에 서버의 부하가 큼.
            - 다양하고 많은 기능을 수행해야 하는 웹 서버는 각 사용자의 변경사항을 빠르게 처리하고 이를 동기화해야 하기 때문에 높은 성능이 요구됨.
            - 이러한 이유로 서버의 부하가 점점 커지고 있고, 백엔드 프레임워크가 고성능을 유지할 필요성이 커지고 있음.
        - **클라우드 비용 절감을 위한 효율적 자원 사용 필요**:
            - 클라우드 서비스는 **사용한 자원만큼 비용이 청구**되는 구조로, 서버의 자원 사용량(예: CPU, 메모리 사용)이 곧 비용과 직결됨.
            - 예를 들어, AWS EC2 인스턴스의 경우 높은 스펙의 인스턴스를 사용할수록 비용이 비싸지므로 **효율적인 자원 사용**이 중요.
            - 기존의 **Node.js나 Python** 기반 백엔드 프레임워크는 상대적으로 높은 CPU 사용률과 메모리 사용량을 보이는 경향이 있으며, 이는 결과적으로 클라우드 비용을 높이는 원인.
            - **경량화된 프레임워크**를 사용하면 클라우드 자원 사용을 줄이고 비용을 절감할 수 있음. 특히 **Rust와 WASM**은 **네이티브 수준의 성능**과 **낮은 메모리 사용량**을 제공하므로 클라우드 환경에서 매우 유리.
            - 또 함수단위로 개별적으로 WASM 모듈로 컴파일하여 클라우드에서 함수단위로 기능을 호출하는 본 연구 프레임워크의 구조를 사용하면 클라우드 환경에서 실행의 독립성을 보장하고 비용 절감을 달성할 수 있음.
        - **경량 웹 프레임워크의 필요성이 대두됨**:
            - 기존의 웹 프레임워크들은 기능이 풍부하지만 그만큼 **무겁고 불필요한 기능**을 포함하는 경우가 많아, 고성능을 요구하는 상황에서는 **오버헤드**로 작용.
            - 예를 들어 **Spring**과 같은 프레임워크는 대규모 애플리케이션에는 유리하지만, 가벼운 서비스에서는 **불필요한 컴포넌트**로 인해 오히려 성능이 저하될 수 있습니다. 또는 필수 라이브러리들의 용량과 메모리 점유로 인해서 소규모 IOT 기기에서 사용이 제한적임
            - **본 연구에서 제안하는 WASM과 Rust를 결합한 시스템 언어 기반의 웹 프레임워크**는 단순한 구조와 최소한의 기능만 제공하여 디스크 용량을 최소화하고 **성능을 최적화할 수 있음.**
            - 이러한 경량화의 필요성은 특히 IOT 기기나 엣지 디바이스등에서 **마이크로서비스 아키텍처**를 채택하는 경우 중요.
            - 이러한 저용량 기기에서 작동하는 마이크로서비스는 각 서비스가 독립적으로 경량화된 상태로 빠르게 동작해야 하므로, 기존의 무거운 프레임워크보다 경량 프레임워크가 적합함.

## 1-2. 연구 목적

- **WASM과 Rust를 결합한 모듈형 웹 백엔드 프레임워크 제안**
    - 높은 성능과 메모리 안전성을 갖춘 프레임워크 개발
    - 모듈화된 구조를 통해 확장성과 유지보수성 향상
- **기존 프레임워크와의 성능 비교를 통한 효과 검증**
    - 다양한 언어와 프레임워크와의 벤치마크를 통해 성능 평가
    - 실제 활용 가능한 경량 웹 서비스용 도구 개발
- **연구목적 정리**
    
    **WASM과 Rust를 결합한 모듈형 웹 백엔드 프레임워크 제안**:
    
    - **높은 성능과 메모리 안전성을 갖춘 프레임워크 개발**:
        - Rust와 WebAssembly(WASM)의 결합은 성능과 메모리 안전성을 보장하는데 유리
        - **Rust**는 시스템 프로그래밍 언어로서 **네이티브 코드 수준의 성능**을 제공하며, **소유권(ownership) 모델**을 통해 **메모리 안전성**을 확보하는데 **데이터 경쟁**이나 **메모리 누수**와 같은 문제를 원천적으로 방지할 수 있음.
        - WASM은 **바이너리 형식의 모듈**로 컴파일되어 다양한 플랫폼에서 **네이티브에 가까운 성능**으로 실행될 수 있어, Rust의 강점을 그대로 활용하면서도 **플랫폼 독립성**을 확보할 수 있음
    - **모듈화된 구조를 통해 확장성과 유지보수성 향상**:
        - 각 기능을 독립적인 **WASM 모듈**로 구현함으로써 **모듈화된 구조**를 제공하며, 이는 **확장성과 유지보수성**을 크게 향상시키려 함.
        - 새로운 기능이 필요할 때 기존의 전체 시스템을 수정하는 대신, **필요한 모듈만 업데이트하거나 추가**할 수 있어 효율적으로 기능 추가가 가능함.
        - 예를 들어, 특정 기능에 대한 수정이 필요할 경우, 해당 기능을 담당하는 WASM 모듈만 수정하고 다시 빌드하여 반영하면 되므로, 전체 시스템에 미치는 영향을 최소화할 수 있음.
        - 또 기능별 함수단위로 컴파일 되어 러스트 WASM 런타임 내에서 개별적으로 호출되므로 함수형 프로그래밍 관점에서 최적화 된 코딩이 가능함
    - **기존 프레임워크와의 성능 비교를 통한 효과 검증**:
        - **다양한 언어와 프레임워크와의 벤치마크를 통해 성능 평가**:
            - Rust-WASM 백엔드 프레임워크의 성능을 검증하기 위해 **다양한 언어와 프레임워크**(예: Node.js 기반의 Express.js, Python의 FastAPI, Java의 Spring 등)와 **벤치마크 테스트**를 수행하려함.
            - 특히 **CPU와 메모리를 집약적으로 사용하는 행렬 곱셈**과 같은 연산을 벤치마크로 사용함으로써, 각 프레임워크의 **성능 한계**를 명확히 파악할 수 있음
        - **실제 활용 가능한 경량 웹 서비스용 도구 개발**:
            - 경량화된 웹 서비스 개발이 중요한 이유는 **클라우드 비용 절감**과 **효율적인 자원 사용**에 있음
            - Rust와 WASM의 결합으로 개발된 백엔드 프레임워크는 기존의 모놀리식 백엔드 프레임워크에 비해 **경량화된 구조**로, **적은 메모리 사용량**과 **짧은 응답 시간**을 제공할 수 있음
            - 이는 **서버리스 컴퓨팅**이나 **엣지 컴퓨팅**과 같은 환경에서도 매우 유리하게 작용할것으로 기대 특히 서버의 자원 사용이 최적화되기 때문에, 클라우드 환경에서 비용 절감 효과가 크며, 다양한 스케일링 상황에서도 안정적으로 운영할 수 있음.

## 1-3. 연구의 당위성 및 의의

- **WASM과 Rust를 활용한 새로운 접근 방식의 필요성**
    - 현대 웹 개발 환경에서의 성능 및 보안 요구 충족
    - 혁신적인 기술적 접근 방식을 통한 문제 해결
- **WASM의 백엔드 적용 의의**
    - **프론트엔드에서 서버로의 WASM 확장**
        - WASM의 활용 범위 확대 및 가능성 탐색
    - **컨테이너 기술의 대안으로서의 가능성**
        - OS 종속성 없이 응용 프로그램 배포 가능
        - 샌드박스 환경을 통한 보안성 강화
    - **적용 의의**
        - **WASM과 Rust를 활용한 새로운 접근 방식의 필요성**:
            - **현대 웹 개발 환경에서의 성능 및 보안 요구 충족**:
                - 현대 웹 개발 환경에서는 **성능**과 **보안**이 매우 중요한 요소임.
                - 기존의 백엔드 프레임워크들은 주로 **인터프리터 언어**나 가비지 컬렉터(GC)를 사용하는 언어들로 작성되어, 성능 면에서 한계가 존재할 수 있음.
                - WASM은 원래 **브라우저 내에서 ,특히 프론트 엔드 영역에서 빠른 속도로 로직을 실행시켜 높은 성능으로 코드를 실행**하기 위해 개발된 기술로, 네이티브 코드에 가까운 성능을 제공함.
                - JS코드를 백엔드에서 사용하는 nodeJS 런타임에서 영감을 받아 이를 백엔드에 활용하면 기존의 자바스크립트 엔진보다 **더 높은 성능**과 **안정적인 메모리 관리**를 통해 **보안성**을 제공할 수 있는 프레임워크를 만들 수 있을 것이라 생각
                - **Rust**의 소유권(ownership) 모델과 **WASM**의 샌드박스 실행 환경을 결합하면, **안전한 메모리 접근**과 **고성능 실행**을 모두 충족시킬 수 있는 새로운 접근 방식을 구현할 수 있음.
            - **혁신적인 기술적 접근 방식을 통한 문제 해결**:
                - WASM과 Rust를 백엔드에 도입함으로써 기존의 백엔드 프레임워크가 가진 문제점을 해결할 수 있는 기회를 제공.
                - 특히 **경량화**와 **모듈화**를 통해 각각의 기능을 독립적으로 실행할 수 있어 확장성과 유지보수성이 향상됨.
                - 이러한 기술적 접근은 **기존에 존재하던 한계**를 뛰어넘어 웹 서비스의 성능을 극대화하고, 복잡한 시스템을 더욱 효율적으로 운영할 수 있는 기회를 창출 할 수 있음.
        - **WASM의 백엔드 적용 의의**:
            - **프론트엔드에서 서버로의 WASM 확장**:
                - WASM(WebAssembly)는 처음에 주로 **브라우저 내에서 고성능 코드**를 실행하기 위해 개발
                - 예를 들어, 복잡한 게임 로직이나 그래픽 처리가 필요한 경우, 자바스크립트 대신 WASM을 사용하면 브라우저에서 훨씬 높은 성능을 낼 수 있음.
                - 이러한 **WASM의 강력한 성능**을 프론트엔드에서 확인한 후, 이를 **서버 측에서도 활용할 수 있다면 성능 향상**에 매우 큰 도움이 될 것이라는 아이디어가 도출 됨.
                - 특히, **Rust로 작성된 코드를 WASM 모듈로 컴파일**하여 백엔드에서 실행하면, 기존의 인터프리터 언어 기반 프레임워크에서 발생하는 성능 저하를 줄이고, 동시에 여러 플랫폼에서 동일한 성능을 보장할 수 있음.
                - **프론트엔드에서의 성공적인 WASM 사용** 경험은, WASM이 백엔드에서도 고성능과 플랫폼 독립성을 동시에 제공할 수 있다는 가능성을 제공
            - **컨테이너 기술의 대안으로서의 가능성**:
                - WASM은 기존의 컨테이너 기술(Docker 등)과 비교했을 때 여러 가지 장점을 가지고 있음.
                - 컨테이너는 응용 프로그램과 그에 필요한 모든 환경을 패키징하여 어디서든 동일하게 실행할 수 있게 해주지만, **운영체제(OS) 종속성**이 존재하고, 여러 컨테이너를 관리하기 위한 오버헤드가 발생할 수 있음.
                - 반면, WASM은 **운영체제에 종속되지 않고** 모든 환경에서 동일하게 실행될 수 있는 바이너리 포맷으로 컴파일됨
                - 이는 궁극적으로 클라우드에서의 **경량화된 배포**를 가능하게 하며, 특히 **엣지 컴퓨팅**과 같이 자원이 제한된 환경에서도 유리.
                - 다만 이 연구에서는 배포의 용이성과 초기 프레임워크 단계에서 설정의 러닝커브로 인해 프레임 워크 발전에 장벽이 되지 않도록 도커 컴포즈를 활용하여 프레임워크를 배포.
                - 또한 WASM은 **샌드박스 환경**에서 실행되므로, 응용 프로그램이 **직접 시스템 자원에 접근하지 못하게 제한**
                - 샌드박스 환경이란 프로그램이 **격리된 공간**에서 실행되어, 외부 자원에 대한 접근 권한을 최소화하는 환경을 의미, 이는 보안적인 측면에서 매우 큰 장점을 가지며, **악성 코드가 시스템 전체에 영향을 미치는 것**을 방지함
                - 기존의 컨테이너 환경은 비교적 넓은 권한을 필요로 하는 반면, WASM은 **필요한 자원만 제한적으로 접근**하기 때문에 보안성 측면에서 매우 강력한 대안
- **백엔드 프레임워크로서 WASM의 혁신적 이점**
    - **플랫폼 독립성:** 다양한 플랫폼에서 동일한 코드 실행 가능
    - **보안성:** 샌드박스 환경에서의 안전한 실행
    - **성능 향상:** 네이티브 코드에 근접한 속도 제공
    - **모듈화와 재사용성:** 기능별 WASM 모듈 분리를 통한 유지보수성 향상
    - **혁신점 이점에 대한 설명**
        
        **백엔드 프레임워크로서 WASM의 혁신적 이점**:
        
        - **플랫폼 독립성: 다양한 플랫폼에서 동일한 코드 실행 가능**:
            - WASM은 **하드웨어와 운영체제에 종속되지 않는 바이너리 형식**으로, **다양한 환경에서 동일한 코드**를 실행할 수 있음.
            - 이는 서버의 운영체제에 상관없이 WASM 모듈을 실행할 수 있다는 의미이며, 이를 통해 **플랫폼 독립성**을 확보할 수 있음.
            - 예를 들어, 동일한 WASM 모듈이 **리눅스 서버, 윈도우 서버, 또는 엣지 디바이스**에서도 동일한 방식으로 동작할 수 있기 때문에, 애플리케이션 개발 시 한 번의 빌드로 다양한 환경에 배포할 수 있는 이점이 있음.
            - 기존에는 운영체제나 하드웨어에 따라 **컴파일 방식이 달라져야 했지만**, WASM을 사용하면 이 과정이 표준화되어 개발 효율성이 크게 향상
        - **보안성: 샌드박스 환경에서의 안전한 실행**:
            - **샌드박스 환경**은 프로그램을 격리된 상태로 실행함으로써, **시스템 자원에 직접 접근하지 못하도록 제한**하는 기술
            - WASM은 이러한 샌드박스 환경에서 동작하기 때문에, WASM 모듈에서 실행되는 코드가 **호스트 시스템의 파일 시스템이나 네트워크 리소스에 직접 접근**할 수 없음.
            - 이는 보안 위협을 원천적으로 차단할 수 있는 중요한 장점 으로 예를 들어, WASM 모듈이 악성 코드라 하더라도, 샌드박스 환경 덕분에 시스템 전체에 피해를 줄 수 없으며, **제한된 리소스에만 접근**하도록 설계할 수 있음
            - 이는 기존의 서버 애플리케이션이 가지고 있던 보안 취약점(예: 권한 상승 공격, 메모리 오버플로우 등)을 크게 줄여줄 수 있는 효과
        - **성능 향상: 네이티브 코드에 근접한 속도 제공**:
            - WASM은 **바이트코드** 형식으로 컴파일되어 **스택 기반 가상 머신**에서 실행되는데 네이티브 코드와 유사한 수준의 성능을 제공하며, 기존의 인터프리터 기반 언어(예: 자바스크립트)보다 훨씬 높은 효율성을 제공
            - WASM은 실행 시 **JIT(Just-In-Time) 컴파일**을 통해 네이티브 기계어로 변환되어 실행되기 때문에, 반복적인 요청을 처리하는 서버 측에서는 인터프리터 언어의 성능 저하 문제를 해결
            - 특히 **Rust로 작성된 WASM 모듈**은 네이티브 수준의 최적화가 가능하여, 웹 애플리케이션에서 발생하는 CPU 집약적인 작업(예: 대규모 데이터 처리, 암호화 연산 등)을 빠르게 처리 가능
        - **모듈화와 재사용성: 기능별 WASM 모듈 분리를 통한 유지보수성 향상**:
            - **모듈화**란 애플리케이션을 여러 개의 독립적인 기능 모듈로 나누어 개발하는 방식을 의미. 연구에서 제안하는 WASM은 기능별로 모듈을 분리하여 작성할 수 있어, 각각의 기능을 별도의 WASM 파일로 빌드하고 필요할 때 동적으로 호출할 수 있음.
            - 이는 각 모듈이 독립적으로 **개발, 테스트, 배포**될 수 있음을 의미합니다. 예를 들어, 특정 기능에 대한 업데이트가 필요할 때, 전체 시스템을 다시 빌드하지 않고 **해당 기능의 모듈만 수정하고 빌드하여 반영,** 시스템 확장 시 각 모듈을 독립적으로 추가하거나 교체할 수 있어 유지보수성이 크게 향상.
            - 또한, 동일한 기능을 여러 프로젝트에서 재사용하고자 할 때, **WASM 모듈을 그대로 가져와 사용**할 수 있음. 이는 WASM이 플랫폼 독립적이라는 특성 덕분에 가능한 것으로, 한 번 작성된 모듈을 다양한 환경과 애플리케이션에서 **중복된 작업 없이 재사용 가능.**
            - 예를 들어, 인증이나 데이터 검증과 같은 공통 기능을 모듈화하여 다양한 서비스에서 사용할 수 있으며, 이는 개발 시간과 비용을 크게 절감.

---

# 2. 연구 내용

## 2-1. 이론적 배경

### 2-1-1. 웹 프레임워크의 정의와 중요성

- **웹 프레임워크의 역할**
    - 웹 애플리케이션 개발을 위한 구조 제공
    - 공통 기능(라우팅, 세션 관리, 인증 등)의 제공으로 개발 효율성 향상
- **현대 웹 개발에서의 중요성**
    - 개발 속도 향상 및 유지보수성 증대
    - 표준화된 개발 방식 제공
- **정의와 중요성 상세**
    
    **웹 프레임워크의 역할**:
    
    - **웹 애플리케이션 개발을 위한 구조 제공**:
        - 웹 프레임워크는 개발자가 **웹 애플리케이션을 구축할 때 필요한 기본 구조와 패턴**을 제공
        - 이는 프로젝트의 기본적인 폴더 구조, 파일 구성, 그리고 코딩 스타일을 표준화하여 모든 개발자가 **일관된 방식으로 개발**할 수 있게 보조
        - 이러한 표준화된 구조는 팀 간의 **협업을 용이하게 하고 코드의 가독성을 높이며**, 신규 개발자들이 프로젝트에 참여할 때 빠르게 적응할 수 있게 도와줌
    - **공통 기능(라우팅, 미들웨어, 응답 추상화 등)의 제공으로 개발 효율성 향상**:
        - 웹 프레임워크는 대부분의 웹 애플리케이션에서 반복적으로 사용되는 **공통 기능**을 내장하여 제공
        - “내용추가”
    - **현대 웹 개발에서의 중요성**:
        - **개발 속도 향상 및 유지보수성 증대**:
            - 웹 프레임워크는 **반복적인 작업을 자동화**하고, 자주 사용되는 기능을 미리 제공함으로써 개발 속도를 크게 높여줍니다. 예를 들어, **Form 데이터의 검증**과 같은 일반적인 작업은 **Flask**나 **Ruby on Rails**와 같은 프레임워크에서 미리 제공하는 기능을 이용해 간단히 구현할 수 있습니다. 개발자가 직접 이러한 기능을 모두 구현한다면 많은 시간이 소요될 뿐 아니라, 버그가 발생할 가능성도 높아집니다.
            - 유지보수성 측면에서, 프레임워크는 **일관된 코드 작성 규칙**과 **모듈화된 구조**를 통해 유지보수하기 쉬운 코드를 작성하도록 돕습니다. 예를 들어, Django 프레임워크는 **MVC(Model-View-Controller) 아키텍처**를 사용하여 코드의 역할을 명확하게 구분합니다. 데이터와 비즈니스 로직, 그리고 사용자 인터페이스를 분리함으로써, 특정 기능을 수정하거나 업데이트할 때 다른 부분에 미치는 영향을 최소화할 수 있습니다. 이는 대규모 프로젝트에서 **버그를 줄이고 개발의 효율성**을 높이는 데 중요한 역할을 합니다.
        - **표준화된 개발 방식 제공**:
            - 웹 프레임워크는 개발자들이 **일관된 방식으로 개발**할 수 있도록 여러 **모범 사례(best practices)**를 내장하고 있습니다. 이러한 표준화된 개발 방식은 프로젝트 간 일관성을 유지하고, 개발 팀 내 모든 개발자가 동일한 규칙을 따르도록 유도합니다. 예를 들어, **RESTful API**의 설계 방식이나 **보안 정책**(예: CSRF, XSS 방어)은 프레임워크에서 표준으로 제공되어, 개발자가 이러한 모범 사례를 쉽게 따를 수 있도록 돕습니다.
            - 이러한 표준화된 개발 방식은 **팀의 생산성 향상**에 기여합니다. 코드의 일관성 덕분에 **새로운 개발자가 프로젝트에 쉽게 적응**할 수 있고, 코드 리뷰와 디버깅도 더 수월해집니다. 또한, 여러 개발자가 동시에 작업할 때 코드의 **충돌을 줄이고 협업 효율성을 높이는** 데 도움을 줍니다. 표준화된 보안 기능과 성능 최적화 방식을 제공함으로써, 개발자는 보안 취약점을 줄이고, 성능 저하 없이 높은 품질의 애플리케이션을 개발할 수 있습니다.

### 2-1-2. WebAssembly(WASM)의 개념과 런타임

- **WASM의 동작 원리**
    - 바이너리 형식의 로우 레벨 스택 기반 가상 머신
    - C, C++, Rust 등으로 작성된 코드를 브라우저와 서버에서 실행 가능
- **WASM 런타임 환경**
    - 브라우저 내장 WASM 엔진
    - 서버 측 WASM 런타임(예: Wasmtime, Wasmer)

### 2-1-3. Rust의 특징과 장점

- **메모리 안전성**
    - 소유권(ownership) 모델을 통한 메모리 관리
    - 데이터 경쟁 및 메모리 누수 방지
- **고성능**
    - 네이티브 코드 컴파일을 통한 높은 성능 제공
- **안정성**
    - 엄격한 컴파일 타임 검사를 통한 코드 품질 향상
- **위 WASM 과 RUST 개념에 대한 더욱 자세한 설명**
    
    ### 2-1-2. WebAssembly(WASM)의 개념과 런타임
    
    - **WASM의 동작 원리**:
        - **바이너리 형식의 로우 레벨 스택 기반 가상 머신**:
            - *WebAssembly(WASM)**는 웹 브라우저나 서버에서 **고성능으로 실행할 수 있는 바이너리 형식**의 코드입니다. 이는 **스택 기반 가상 머신**에서 실행되며, 스택 기반이란 명령어를 처리할 때 스택 자료 구조를 사용하여 연산을 수행한다는 의미입니다. 이러한 구조는 메모리 관리가 간단하고 효율적이어서 **경량화된 실행 환경**을 구축하는 데 매우 유리합니다.
            - WASM은 **텍스트 형식(WAT, WebAssembly Text Format)**과 **바이너리 형식(Wasm 바이너리)** 두 가지로 표현될 수 있습니다. 바이너리 형식은 텍스트 형식보다 훨씬 **압축된 형태**로, 실행 환경에서 빠르게 로드되고 **적은 메모리**를 사용하여 효율성을 높입니다. 따라서 웹 페이지나 서버 애플리케이션에서 필요할 때 즉시 실행할 수 있는 이점이 있습니다.
        - **C, C++, Rust 등으로 작성된 코드를 브라우저와 서버에서 실행 가능**:
            - WASM은 **C, C++, Rust 등 고성능을 제공하는 언어로 작성된 코드를 컴파일**하여 사용할 수 있습니다. 이러한 언어들은 모두 **컴파일러(예: LLVM)**를 통해 WASM 형식으로 변환될 수 있으며, 이를 통해 **브라우저나 서버에서 네이티브에 가까운 성능**을 제공합니다. 기존의 자바스크립트는 인터프리터 언어로, 코드가 실행될 때 해석되기 때문에 복잡한 연산을 수행할 때 성능에 한계가 있었습니다. 그러나 WASM을 사용하면, 복잡한 계산이나 데이터 처리도 **브라우저 내에서 거의 네이티브 수준의 속도**로 수행할 수 있게 되어 웹 애플리케이션의 성능을 크게 향상시킬 수 있습니다.
            - **게임 엔진, 머신러닝 모델, 그래픽 처리**와 같이 CPU 자원을 많이 사용하는 애플리케이션에서 WASM은 자바스크립트보다 훨씬 빠르게 실행되며, 특히 **병렬 처리가 필요한 연산**에서 큰 성능 향상을 기대할 수 있습니다.
    - **WASM 런타임 환경**:
        - **브라우저 내장 WASM 엔진**:
            - 대부분의 최신 브라우저(예: **Chrome, Firefox, Safari, Edge**)는 이미 WASM을 실행할 수 있는 **내장 엔진**을 가지고 있습니다. 이 엔진들은 **JIT(Just-In-Time) 컴파일** 방식을 사용하여, WASM 코드를 실행 시점에 네이티브 기계어로 변환하고, 이를 통해 빠르게 실행할 수 있습니다. WASM의 이러한 특성은 브라우저 내에서 복잡한 계산을 빠르게 처리해야 하는 애플리케이션(예: **3D 렌더링** 또는 **데이터 시각화**)에서 유용합니다. 또한, WASM은 **샌드박스 환경**에서 실행되므로, 보안성을 유지하면서도 네이티브 성능을 제공합니다.
        - **서버 측 WASM 런타임(예: Wasmtime, Wasmer)**:
            - WASM은 브라우저뿐만 아니라 **서버 측에서도 실행**될 수 있습니다. 이를 위해 개발된 런타임 환경이 **Wasmtime**, **Wasmer**와 같은 서버 측 WASM 런타임입니다. 이러한 런타임은 브라우저와는 별도로 서버에서 WASM 모듈을 로드하고 실행하는 기능을 제공하며, 이는 **컨테이너 기술의 대안**으로도 활용될 수 있습니다.
            - 예를 들어, 기존의 서버 애플리케이션은 특정 언어나 플랫폼에 종속적일 수 있었지만, WASM 런타임을 이용하면 서버 환경에서 **어떤 언어로 작성된 코드든** WASM 형식으로 컴파일하여 실행할 수 있어 **플랫폼 독립성**을 확보할 수 있습니다. Wasmtime과 Wasmer는 이러한 WASM 모듈을 가볍고 빠르게 실행할 수 있도록 최적화되어 있으며, 특히 **엣지 컴퓨팅**과 같이 자원이 제한된 환경에서 **효율적인 실행**을 보장합니다.
    
    ### 2-1-3. Rust의 특징과 장점
    
    - **메모리 안전성**:
        - **소유권(ownership) 모델을 통한 메모리 관리**:
            - **Rust**는 고성능 시스템 언어로, **메모리 안전성**을 보장하는 **소유권(ownership) 모델**을 제공합니다. 이 모델은 **변수의 소유권**을 통해 컴파일 시점에 메모리 관리 규칙을 검사하여 **데이터 경쟁(data race)**이나 **메모리 누수**와 같은 문제를 방지합니다. 소유권 모델은 각 변수에 대해 **하나의 소유자**만을 허용하고, 소유권이 **함수 간 전달**될 때 명시적으로 처리하도록 합니다.
            - Rust에서는 **스마트 포인터(Box, Rc, Arc 등)**를 통해 메모리를 효율적으로 관리하며, 사용이 끝난 메모리는 자동으로 반환됩니다. 이는 **가비지 컬렉터(GC)**를 사용하는 다른 언어들(Java, C#)과 달리 런타임 오버헤드 없이 메모리를 안전하게 관리할 수 있음을 의미합니다. 따라서 Rust는 성능을 최적화하면서도 **안전한 메모리 관리**를 가능하게 합니다.
        - **데이터 경쟁 및 메모리 누수 방지**:
            - 데이터 경쟁은 여러 스레드가 동시에 **공유 자원**에 접근하고, 이 과정에서 예상치 못한 문제가 발생하는 현상입니다. Rust의 **소유권 모델**과 **빌림(borrowing) 검사**는 **컴파일 타임에 데이터 경쟁을 방지**하여, 멀티스레드 환경에서도 안전한 동작을 보장합니다. 이러한 특성은 **고성능 네트워크 서버**나 **멀티스레드 병렬 처리**가 중요한 애플리케이션 개발 시 큰 장점이 됩니다.
            - 또한, Rust는 **사용되지 않는 메모리를 자동으로 해제**하므로, **메모리 누수(memory leak)** 문제가 발생할 가능성을 줄입니다. 이는 시스템 자원이 제한된 환경에서도 안정적인 프로그램 실행을 보장하게 해 줍니다.
    - **고성능**:
        - **네이티브 코드 컴파일을 통한 높은 성능 제공**:
            - Rust는 **LLVM 컴파일러 인프라**를 사용하여 **네이티브 코드**로 컴파일됩니다. 네이티브 코드는 기계어 수준의 명령어로 변환되기 때문에, Rust로 작성된 애플리케이션은 **최적화된 성능**을 제공합니다. 이는 **C/C++**에 비견될 정도로 높은 성능을 의미하며, Rust는 이러한 성능을 **메모리 안전성**과 동시에 달성할 수 있는 언어로 각광받고 있습니다.
            - 예를 들어, **고속 네트워킹 라이브러리**나 **시스템 수준의 성능이 중요한 게임 엔진** 개발에 Rust가 사용되고 있으며, 이러한 분야에서는 **성능과 안전성**이 모두 요구되기 때문에 Rust가 최적의 선택이 될 수 있습니다.
    - **안정성**:
        - **엄격한 컴파일 타임 검사를 통한 코드 품질 향상**:
            - Rust의 또 다른 중요한 특징은 **컴파일 타임 검사**를 통해 **코드 품질**을 높인다는 점입니다. Rust 컴파일러는 변수의 소유권, 참조 유효성, 메모리 접근 등과 관련된 다양한 검사(ownership, borrowing rules 등)를 **컴파일 시점**에 수행하여, 런타임 오류를 방지합니다. 이는 개발자가 **런타임에서 발생할 수 있는 오류**를 미리 발견하고 수정할 수 있도록 하여, **안정적이고 신뢰할 수 있는 코드**를 작성하게 합니다.
            - Rust는 또한 **Option** 타입과 **Result** 타입을 통해 **널 포인터 참조**와 같은 위험을 방지하며, 함수의 성공 여부를 명시적으로 처리하도록 유도합니다. 이러한 방식은 코드의 **명확성**과 **안정성**을 높이는 데 기여하며, 복잡한 애플리케이션에서도 **신뢰성 높은 코드를 유지**할 수 있게 합니다.

### 2-1-4. 기존 프레임워크 소개

- **Go 기반 프레임워크**
    - **Gin:** 경량 웹 프레임워크로 빠른 성능 제공
    - **Echo:** 고성능과 유연성을 갖춘 프레임워크
- **Node.js 기반 프레임워크**
    - **Express.js:** 널리 사용되는 웹 프레임워크로 유연성과 단순함 제공
    - **Bun.js:** Node.js의 대안 런타임으로 빠른 성능 제공
- **Java 프레임워크**
    - **Spring:** 엔터프라이즈급 애플리케이션 개발에 널리 사용
- **Python 프레임워크**
    - **FastAPI:** 비동기 기능 지원으로 높은 성능 제공

## 2-2. 제안 프레임워크의 설계 철학과 원칙

### 2-2-1. 성능 최적화와 단순한 구조

- 불필요한 복잡성 제거하고 성능에 집중
- 최소한의 레이어로 구성하여 오버헤드 감소

### 2-2-2. KISS(Keep It Simple, Stupid) 원칙 준수

- 단순하고 이해하기 쉬운 구조 유지
- 개발자 경험 향상을 위한 간결한 인터페이스 제공

### 2-2-3. WASM 모듈화 기능 및 자동 빌드 지원

- 기능별로 독립된 WASM 모듈로 분리
- 자동 빌드 시스템을 통해 개발 효율성 향상

### 2-2-4. 미들웨어 시스템 설계

- 확장성과 유연성을 위한 미들웨어 아키텍처 도입
- 인증, 로깅, 에러 처리 등의 기능을 유연하게 추가 가능

### 2-2-5. SOLID 원칙 중 단일 책임 원칙(SRP) 강조

- 각 모듈과 구성 요소가 하나의 책임만 가지도록 설계
- 유지보수성과 확장성 향상

## 2-3. 프레임워크 구현

### 2-3-1. 개발 환경

- **사용 언어 및 버전**
    - Rust 최신 버전 사용 (1.80 이상)
- **사용 라이브러리**
    - **Hyper:** 비동기 HTTP 라이브러리
    - **Wasmtime:** WASM 런타임
- **개발 도구**
    - **Cargo:** Rust의 패키지 매니저이자 빌드 도구
    - **Bash 스크립트:** 빌드 자동화 구현

### 2-3-2. WASM 모듈화 기능 함수 구현

- 각 기능을 WASM 모듈로 컴파일
- 런타임에서 동적으로 로드하여 호출
- Wasmtime 라이브러리를 사용하여 WASM 모듈 실행

### 2-3-3. 미들웨어 구현

- 인증, 권한 부여, 입력 검증 등을 위한 미들웨어 시스템 구현
- 유연한 확장성을 위해 가드 패턴 적용

### 2-3-4. HTTP 라우팅 구현

- Hyper 라이브러리를 래핑하여 자체 라우팅 시스템 개발
- 경로 매핑과 HTTP 메서드 처리를 관리

### 2-3-5. 요청 및 응답 추상화

- 요청(Request)과 응답(Response)을 추상화하여 개발 편의성 제공
- 개발자가 쉽게 요청 정보를 다루고 응답 생성 가능

### 2-3-6. 자동 빌드 스크립트 작성

- Bash 스크립트를 활용하여 WASM 모듈의 자동 빌드 및 배포 설정
- Cargo와 Bash 스크립트를 결합하여 빌드 과정 자동화

## 2-4. WASM을 백엔드에 적용한 의의

- **프론트엔드에서 백엔드로의 WASM 확장**
    - WASM의 활용 범위 확대 및 가능성 탐색
- **컨테이너 기술의 대체 가능성**
    - OS 종속성 없이 애플리케이션 실행
    - 샌드박스 환경을 통한 보안성 강화
- **백엔드 프레임워크로서의 WASM의 장점**
    - **플랫폼 독립성:** 다양한 플랫폼에서 동일한 코드 실행
    - **보안성:** 시스템 자원에 대한 직접 접근 제한으로 보안 강화
    - **성능 향상:** 네이티브 코드에 근접한 성능 제공
    - **모듈화와 재사용성:** 기능 분리를 통한 유지보수성 및 확장성 향상
- **의의에 대한 타당성 추가**
    
    ## 2-4. WASM을 백엔드에 적용한 의의
    
    - **프론트엔드에서 백엔드로의 WASM 확장**:
        - **WASM의 활용 범위 확대 및 가능성 탐색**:
            - WASM(WebAssembly)은 원래 **웹 브라우저 내에서의 성능 문제**를 해결하기 위해 개발되었습니다. 자바스크립트는 웹에서 널리 사용되지만, **실시간 데이터 처리나 복잡한 계산**이 필요한 애플리케이션에서 성능의 한계가 있었습니다. 이를 해결하기 위해 WASM은 브라우저 내에서 **네이티브에 가까운 성능**을 제공하는 목표로 등장하였고, 고성능 언어(C, C++, Rust 등)로 작성된 코드를 컴파일하여 **브라우저에서 빠르게 실행**할 수 있도록 해주었습니다.
            - 이러한 WASM의 특성이 백엔드에도 적용될 수 있는 가능성을 열어주었습니다. 기존에는 주로 **자바스크립트 엔진(Node.js 등)**이 백엔드에서 사용되었으나, **성능이 중요한 작업**에서는 한계가 있었습니다. WASM을 백엔드로 확장하여, 복잡한 계산이 필요한 부분을 WASM 모듈로 처리함으로써 **백엔드에서도 성능을 크게 향상**시킬 수 있는 가능성을 제시합니다. 예를 들어, **이미지 처리, 데이터 분석, 암호화 연산**과 같은 CPU 집약적인 작업을 WASM 모듈로 처리하면 기존의 자바스크립트 기반 백엔드보다 훨씬 더 **빠르고 효율적인 응답**을 제공할 수 있습니다.
            - WASM의 백엔드 적용은 웹 개발의 **일관된 기술 스택**을 유지하면서도 성능을 최적화하는 데 도움을 줍니다. 프론트엔드와 백엔드 모두에서 WASM 모듈을 사용함으로써, **코드 재사용**이 가능하고, 개발자들이 동일한 방식으로 코드를 작성하고 관리할 수 있게 되어 **개발 경험을 단순화**할 수 있습니다.
    - **컨테이너 기술의 대체 가능성**:
        - **OS 종속성 없이 애플리케이션 실행**:
            - 기존의 **컨테이너 기술(Docker 등)**은 애플리케이션과 그에 필요한 모든 라이브러리를 패키징하여 여러 환경에서 동일하게 실행할 수 있도록 해주는 도구입니다. 하지만 이러한 컨테이너는 여전히 **호스트 운영체제(OS)에 종속적**이며, 호스트 커널을 공유하기 때문에 **OS별 차이**가 존재할 수 있습니다. WASM은 이러한 종속성에서 벗어나, **어떤 운영체제에서도 동일하게 실행**될 수 있는 **플랫폼 독립적인 바이너리 형식**입니다. 이는 클라우드 환경이나 엣지 컴퓨팅처럼 **다양한 하드웨어와 OS**에서 동작해야 하는 경우, **효율적이고 일관된 실행 환경**을 제공할 수 있음을 의미합니다.
            - 예를 들어, 특정 기능을 수행하는 WASM 모듈을 한 번 컴파일하면 **리눅스 서버, 윈도우 서버, ARM 기반의 엣지 디바이스**에서도 그대로 사용할 수 있습니다. 이는 각 환경에 맞춰 컴파일하거나 패키징할 필요 없이 **단일 바이너리**로 다양한 환경을 지원할 수 있는 장점을 제공합니다. 이러한 특성 덕분에 WASM은 컨테이너 기술의 **대체재 혹은 보완재**로써 역할을 할 수 있으며, 특히 **자원 소비가 적고 경량화된 애플리케이션**을 실행할 때 유리합니다.
        - **샌드박스 환경을 통한 보안성 강화**:
            - **샌드박스 환경**이란 프로그램이 **격리된 상태**에서 실행되어, 외부 자원(파일 시스템, 네트워크 등)에 접근하지 못하도록 제한하는 실행 환경을 의미합니다. WASM은 이러한 **샌드박스 특성**을 기본적으로 제공하므로, WASM 모듈이 외부 시스템 자원에 직접 접근하는 것을 제한하여 **보안성을 강화**할 수 있습니다. 이는 WASM 모듈이 의도치 않은 시스템 자원에 접근하여 문제를 일으키거나, 악의적인 코드를 실행하려는 시도를 효과적으로 방지할 수 있음을 의미합니다.
            - 기존의 컨테이너는 호스트 운영체제와 자원을 공유하기 때문에, **보안 취약점**이 발생할 경우 호스트 시스템 전체에 영향을 미칠 수 있는 위험이 있었습니다. 반면, WASM은 이러한 **직접적인 접근 경로**를 차단하고, 애플리케이션이 허용된 자원만을 사용할 수 있도록 제한하기 때문에 **보안 측면에서 매우 유리**합니다. 특히 **멀티 테넌트 환경**(여러 사용자가 동일한 서버 자원을 공유하는 경우)에서, 각 사용자의 애플리케이션을 WASM으로 격리하여 실행하면 보안 위협을 최소화할 수 있습니다.
    - **백엔드 프레임워크로서의 WASM의 장점**:
        - **플랫폼 독립성: 다양한 플랫폼에서 동일한 코드 실행**:
            - WASM은 특정 운영체제나 하드웨어에 종속되지 않는 **중립적인 형식**으로 컴파일되기 때문에, 한 번 작성된 코드가 **모든 환경에서 동일하게 실행**될 수 있습니다. 이는 웹 애플리케이션의 경우, **서버 환경이 다르더라도 WASM 모듈을 동일하게 사용**할 수 있어 개발 효율성을 크게 높여줍니다. 예를 들어, 리눅스 서버에서 개발한 기능을 윈도우 서버로 이전하거나, 클라우드 서비스와 엣지 디바이스에서 동일한 코드를 사용할 수 있는 **일관된 실행 환경**을 제공합니다. 이러한 플랫폼 독립성은 유지보수의 복잡성을 줄이고, 다양한 환경에서 **확장성 높은 서비스**를 제공하는 데 중요한 역할을 합니다.
        - **보안성: 시스템 자원에 대한 직접 접근 제한으로 보안 강화**:
            - WASM은 **기본적으로 시스템 자원에 대한 접근이 제한**되어 있으며, 이로 인해 WASM 모듈은 필요한 자원에 대해 **명시적인 권한**을 부여받아야만 접근할 수 있습니다. 이는 **보안 취약점**을 줄이는 데 큰 도움이 되며, 특히 **네트워크 보안이나 파일 시스템 접근 제어**와 같은 부분에서 중요한 역할을 합니다. WASM의 샌드박스 특성은 각 WASM 모듈이 **격리된 환경**에서 실행됨을 보장하며, 이는 악성 코드가 시스템 전체에 영향을 미치지 않도록 합니다. 이러한 특성 덕분에, WASM은 기존의 서버 애플리케이션에서 발생할 수 있는 **보안 위협**을 줄이고 **신뢰성 높은 애플리케이션**을 제공할 수 있습니다.
        - **성능 향상: 네이티브 코드에 근접한 성능 제공**:
            - WASM은 **JIT(Just-In-Time) 컴파일**과 **AOT(Ahead-Of-Time) 컴파일**을 통해 실행되며, 이는 네이티브 기계어 수준으로 코드가 변환되어 **높은 실행 성능**을 제공합니다. WASM은 자바스크립트와 비교했을 때 복잡한 연산이나 **반복적인 작업**에서 **훨씬 높은 성능**을 나타냅니다. 예를 들어, 이미지 처리나 암호화와 같이 많은 계산이 필요한 작업에서도 WASM은 네이티브 코드에 근접한 속도로 실행되므로, 이러한 기능을 백엔드에서 WASM으로 처리하면 서버 응답 시간을 크게 줄일 수 있습니다. 이처럼 성능 향상을 통해 **사용자 경험**을 개선하고, 서버의 부하를 효율적으로 관리할 수 있습니다.
        - **모듈화와 재사용성: 기능 분리를 통한 유지보수성 및 확장성 향상**:
            - WASM을 백엔드에서 사용할 때의 중요한 이점 중 하나는 **모듈화된 구조**를 통해 **기능을 독립적으로 개발하고 배포**할 수 있다는 점입니다. WASM 모듈로 각 기능을 나누어 개발하면, 특정 기능에 대한 수정이나 확장 시 **전체 시스템에 영향을 주지 않고 해당 모듈만 업데이트**할 수 있습니다. 이는 유지보수를 단순화하고, 새로운 기능을 쉽게 추가할 수 있어 **확장성**이 크게 향상됩니다.
            - 또한, 한 번 개발된 WASM 모듈은 다른 프로젝트나 서비스에서도 **재사용**할 수 있습니다. 예를 들어, 인증 모듈이나 데이터 검증 모듈을 WASM으로 구현하면, 이 모듈을 다른 여러 프로젝트에서 그대로 사용할 수 있습니다. 이러한 재사용성은 **개발 비용 절감**과 **코드 일관성**을 유지하는 데 큰 기여를 하며, WASM 모듈을 통해 각 기능을 독립적으로 제공하고 **확장 가능한 서비스 아키텍처**를 구성할 수 있게 합니다.

---

# 3. 연구 결과

## 3-1. 벤치마킹 실험 설계

### 3-1-1. 비교 대상 프레임워크 선정

- **자체 개발한 프레임워크**
- **비교 대상 프레임워크 5개**
    - **Go 기반 프레임워크:** Gin
    - **Node.js 기반 프레임워크:** Express.js
    - **Bun.js 런타임에서의 Express.js**
    - **Java 프레임워크:** Spring
    - **Python 프레임워크:** FastAPI

### 3-1-2. 성능 비교를 위한 행렬 곱셈 테스트

- **행렬 크기:** 100×100부터 5000×5000까지 다양한 크기
- **선택 이유:** CPU와 메모리를 집약적으로 사용하는 연산으로, 언어와 프레임워크의 성능 비교에 적합

### 3-1-3. 반복 실행 및 통계 처리

- 각 테스트를 **30회 반복 실행**하여 평균값 및 표준편차 계산
- 실행 환경의 변동성을 줄이고 통계적 신뢰도 향상

### 3-1-4. 측정 지표 및 데이터 수집 방법

- **실행 시간:** 고해상도 타이머를 사용하여 밀리초(ms) 단위로 측정
- **메모리 사용량:** 시스템 모니터링 도구를 활용하여 프로세스의 최대 메모리 사용량 기록

### 3-1-5. 결과 해석 및 통계 검정 방법

- **가설 검정:** t-검정, ANOVA 등을 통해 결과의 통계적 유의성 검증
- 프레임워크 간 성능 차이가 우연이 아님을 입증

## 3-2. 실험 데이터 정리

- 각 행렬 크기별 **수행 시간 표** 및 **그래프** 작성
- 언어/프레임워크별 성능 비교를 위한 데이터 체계화
- 메모리 사용량 데이터 수집 및 정리

## 3-3. 결과 시각화

- **선형 그래프 및 로그 스케일 그래프 활용**
    - 실행 시간 비교 그래프 작성
    - 로그 스케일을 통해 큰 값의 차이 명확히 표현
- **막대 그래프 작성**
    - 메모리 사용량 비교를 위한 그래프 작성

## 3-4. 성능 분석

### 3-4-1. 자체 프레임워크의 우수성 분석

- **기존 프레임워크 대비 성능 향상 정도 평가**
    - WASM과 Rust의 결합이 성능에 미친 영향 분석
- **큰 규모의 행렬에서 뛰어난 성능 발휘**
    - 네이티브에 근접한 실행 속도로 우수한 결과 도출

### 3-4-2. 작은 행렬에서의 오버헤드 분석

- **WASM 초기화 오버헤드로 인한 성능 저하 원인 분석**
    - 작은 규모의 연산에서는 초기화 시간이 상대적으로 큰 비중 차지
- **개선 방안 제시**
    - WASM 모듈의 초기화 최적화
    - 초기화 비용을 줄이기 위한 캐싱 전략 도입

### 3-4-3. 통계적 유의성 검증

- **가설 검정을 통한 결과의 신뢰성 확보**
    - 각 프레임워크 간 성능 차이가 통계적으로 유의함을 입증
- **p-값 및 신뢰 구간 제시**

## 3-5. 결과 시사점

- **설계 철학의 타당성 검증**
    - 경량 프레임워크의 효용성과 단순한 설계의 효과 확인
- **연구의 한계점**
    - 실험 환경의 제약 및 오버헤드 분석의 한계
    - 다양한 하드웨어 및 운영체제 환경에서 추가 실험 필요
- **향후 보완점과 연구 방향**
    - **웹 프레임워크 기능 추가 예정**
        - 인증 시스템, 데이터베이스 연동 등
    - **멀티스레딩 지원 및 다양한 연산 테스트 추가 계획**
        - 멀티코어 프로세서 활용을 통한 성능 향상 연구

---

# 4. 결론

## 4-1. 연구 요약

- **WASM과 Rust를 결합한 모듈형 웹 백엔드 프레임워크를 설계하고 구현**
    - 성능 최적화와 단순한 구조를 갖춘 프레임워크 개발
- **벤치마킹을 통한 성능 검증**
    - 기존 프레임워크 대비 우수한 성능을 확인하고, 설계 철학의 타당성 입증

## 4-2. 주요 발견과 기여

- **자체 프레임워크의 우수한 성능 확인**
    - 큰 규모의 연산에서 뛰어난 성능 발휘
- **모듈화된 WASM 구조의 장점 입증**
    - 유지보수성 및 확장성 향상
- **웹 개발 분야에 새로운 가능성 제시**
    - WASM의 백엔드 적용을 통한 혁신적 접근 방식 제안

## 4-3. 기대 효과

- **고성능 웹 개발에 기여**
    - 서버 자원 효율화 및 클라우드 비용 절감
- **경량화된 프레임워크의 활용 촉진**
    - 개발자 경험 향상 및 생산성 증대

## 4-4. 다양한 분야에서의 적용 방안

- **서버리스 컴퓨팅**
    - 경량성과 빠른 실행을 통한 서버리스 환경에 적합
- **마이크로서비스 아키텍처**
    - 모듈화된 구조로 마이크로서비스 구현에 용이
- **IoT 및 엣지 컴퓨팅**
    - 제한된 자원 환경에서의 효율적인 애플리케이션 실행

## 4-5. 연구의 의의 및 미래 전망

- **웹 개발 패러다임의 전환**
    - WASM 기반 백엔드의 가능성 제시로 새로운 방향성 제시
- **컨테이너 기술의 대안 모색**
    - WASM을 통한 경량화된 배포 및 실행 환경 제공
- **산업계 및 학계에서의 활용 기대**
    - 고성능이 요구되는 분야에서의 적용 가능성 및 추가 연구 기대

---

## 5. 참고문헌

- **WebAssembly 공식 문서 및 사양**
- **Rust 프로그래밍 언어 공식 가이드**
- **Hyper 및 Wasmtime 라이브러리의 문서화 자료**
- **각 비교 대상 프레임워크의 공식 문서 및 벤치마크 자료**
- **관련 논문 및 기술 보고서**

---

## 부록

- **실험 데이터 (CSV 파일)**
    - 30회씩 실행한 자료를 CSV로 정리하여 첨부
- **차트 및 그래프**
    - 실행 시간 및 메모리 사용량 비교 그래프
    - 로그 스케일 그래프 등 추가 시각 자료 제공